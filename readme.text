Q. Explain different ways to create objects:

1. Using new operator :

- The most basic ans used way to create an object.

- It uses the new keyword along with the class constructor to create an instance of that
class

- example :

        Student obj1 = new Student(24, "TJ");

2. Using clone()

- Clone returns a exact copy of the object on which clone is invoked

- For using clone(), the Class needs to implement the Cloneable interface and
override the clone() method based on the requirement whether you want Deep Clone
or Shallow Clone

3. Using Reflection API :

- We can use the reflection API to create new object by using the getConstructor()
and newInstance() method.

- Example :

Student obj3 = Student.class.getConstructor().newInstance();

- this approach only works for the public constructors and trying to use a private
constructor will throw IllegalAccessException.

- useful for Flexible object creation at runtime with specific constructors

4. Using the supplier functional interface and lambda expression

- Provide implementation for Supplier FI to return new instance of class.

- Use the get method reference to obtain a new object

- Example :

        Supplier<Student> imp = Student::new;
        Student obj4 = imp.get();

5. Serialisation and Deserialisation. Useful for data persistence and object transfers over
network

6. Factory Method - exactly same as a Singleton class. a private constructor and a static
method to return the object

7. Reflection.newInstance() - a method of Reflection API that was deprecated in Java 9
but to performance issue. Used when class name is only known at runtime

8. Implementation :

package com.interview.interview_poc;


import java.lang.reflect.InvocationTargetException;
import java.util.function.Supplier;

public class Student implements Cloneable {

    private int id;
    private String name;

    public Student() {

    }

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }

    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {

        System.out.println("Ways to create objects");

        System.out.println("1. using the new operator");
        Student obj1 = new Student(24, "TJ");
        System.out.println(obj1);

        System.out.println("2. using clone method");
        Student obj2 = obj1.clone();
        System.out.println(obj2);
        System.out.println("Are original and clone same object : " + (obj1==obj2));

        System.out.println("3. using the reflection API");
        Student obj3 = Student.class.getConstructor().newInstance();
        obj3.setId(23);
        obj3.setName("John");
        System.out.println(obj3);

        System.out.println("4. Using Lambda");
        Supplier<Student> imp = Student::new;
        Student obj4 = imp.get();
        obj4.setId(22);
        obj4.setName("Dennis");
        System.out.println(obj4);
    }

    @Override
    public Student clone() {
        try {
            Student clone = (Student) super.clone();
            // TODO: copy mutable state here, so the clone can't change the internals of the original
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new AssertionError();
        }
    }
}

9. Result :

Ways to create objects
1. using the new operator
Student{id=24, name='TJ'}
2. using clone method
Student{id=24, name='TJ'}
Are original and clone same object : false
3. using the reflection API
Student{id=23, name='John'}
4. Using Lambda
Student{id=22, name='Dennis'}
